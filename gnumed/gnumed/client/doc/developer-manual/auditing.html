<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Table auditing</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="GNUMed"
HREF="index.html"><LINK
REL="UP"
TITLE=" Design "
HREF="design.html"><LINK
REL="PREVIOUS"
TITLE="Gnumed EMR"
HREF="emr-design.html"><LINK
REL="NEXT"
TITLE="GUI design"
HREF="gui-design.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GNUMed: Developers's Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="emr-design.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 5. Design</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="gui-design.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AUDITING"
>5.7. Table auditing</A
></H1
><P
>&#13;	    From a medico-legal point of view it is important to track who
	    changed what data when. GnuMed uses database level facilities
	    to achieve that goal. Advantages are that SQL query parsing is
	    left to the database engine, that the backend provides uniform
	    auditing across any variety of client, and that auditing data is
	    moved locally which provides for reasonable speeds. Drawbacks are
	    that audit trail data cannot be transferred remotely right away
	    particularly conveniently and that this scheme is not foolproof
	    against manipulation.

    	    </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN807"
>5.7.1. INSERT</A
></H2
><P
>		On INSERT the committer and the current timestamp is added to
		the table data. Row versioning is initialized to 0. No data
		is transferred to the corresponding audit trail table.
	    	</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN810"
>5.7.2. UPDATE, DELETE</A
></H2
><P
>		On any of those two operations the original row version, data,
		committer, timestamp and table OID are logged in the audit trail
		table. The current timestamp, committer and action (DELETE or
		UPDATE) are added. For updates, the row version in the original
		table is incremented and the timestamp and committer are
		updated to the current values.
	    	</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN813"
>5.7.3. SELECT</A
></H2
><P
>		Currently SELECTs are not logged. While some legislation may
		require this it does not make sense technically, will slow down
		the database considerably and is better left to middleware
		or frontend. The main argument against SELECT logging at the
		database level is that the intended purpose of it would be to
		enable later investigation of unauthorized disclosure. However,
		a logged SELECT in no way proves any disclosure to any specific
		target. A missing SELECT does not contribute any useful evidence
		against disclosure either. Unauthorized disclosure is largely
		a social-control/policy issue. There's no such thing as
		"unauthorized access". If access occurred it was authorized
		(barring any software bugs). Such security breaches must be
		prevented by other means.
	    	</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN816"
>5.7.4. How to add an audit trail to a table</A
></H2
><P
>		Any table that is supposed to be audited must be marked
		for auditing by calling the plpgsql function
		"add_table_for_audit(table_name)". During bootstrapping
		audit trail tables are auto-generated for all the tables
		marked for auditing. It is also possible to manually
		create audit trail tables in which case they need not
		contain all the columns in the respective audited table
		(but they must not have any extra columns). In case of
		manually setting up audit trail tables make sure they
		inherit from the root table "audit_trail".
	    	</P
><P
>		During bootstrapping all marked tables that have a
		corresponding audit trail table are prepared for
		auditing. The necessary functions and triggers are
		automatically generated and inserted into the database.
		The audit trail tables will have the name of the
		audited table prefixed with "log_".
	    	</P
><P
>		Please read the source in <TT
CLASS="FILENAME"
>		server/bootstrap/gmAuditSchemaGenerator.py</TT
> and
		<TT
CLASS="FILENAME"
>server/bootstrap/boostrap*.py</TT
> to learn how to manually
		create audit trails.
	    	</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN823"
>5.7.5. Audit trail handling</A
></H2
><P
>		Over time the audit trail tables may grow quite large.
		They may be dumped and cleaned out regularly. The
		dump file should be notarized digitally and backed up.
		Preferably an unsigned online copy of the audit trail
		tables should be moved to another server. It is useful
		to have the complete revision history online for
		reference but this is not speed-critical.
	    	</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="emr-design.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="gui-design.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Gnumed EMR</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="design.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>GUI design</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>