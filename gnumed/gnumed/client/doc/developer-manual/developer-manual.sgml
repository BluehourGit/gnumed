<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.1//EN">

<book>
   <bookinfo>
     <date>2002-09-03</date>
     <title>GNUMed</title>
     <subtitle>Developers's Manual</subtitle>
    
	<author>	
      		<firstname>Gerardo</firstname>
		<surname>Arnaez</surname>
      	</author>

     	<author>	
      		<firstname>Hilmar</firstname>
		<surname>Berger</surname>
    	</author>


<abstract>
	<para>      
      Copyright (c) 2001,2002 GNUMed developers</para>
      <para>
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.1
      or any later version published by the Free Software Foundation;
      with no Invariant Sections, with no
      Front-Cover Texts, and with no Back-Cover Texts.</para>
      <para>
      A copy of the license is included in the section entitled "GNU
      Free Documentation License".</para>
   </abstract>

<revhistory>
      <revision>
	<revnumber>0.1.1</revnumber>
	<date>2002-08-12</date>
	<authorinitials>hb</authorinitials>
	<revremark>Added some basic description of gnumed client modules.</revremark>
      </revision>


      <revision>
	<revnumber>0.1</revnumber>
	<date>2002-08-03</date>
	<authorinitials>gea</authorinitials>
	<revremark>Initial developers manual written, mostly will copy from savanah.gnu.org</revremark>
      </revision>


    </revhistory>


   </bookinfo>
   <toc></toc>

<preface>
	<title>Preface</title>
	<para>GnuMed never sleeps.</para>
</preface>

<chapter id="intro">
     <title>Introduction</title>

    <para>GNUMed is  a comprehensive scalable software solution for paperless 
medical practice with emphasis on privacy protection, secure patient-centric 
record sharing, decision support and ease of use.
</para>
       <para>GNUMed is not yet ready for download as a package.
It will become available at 
<ulink url="http://gnumed.org/">
<citetitle>gnumed.org</citetitle></ulink>.
 
It is released under the GNU 
General Public Licence, see the file <filename>LICENCE</filename> for details.
</para>

  </chapter>

  <chapter>
    <title>Checking out, Checking in GnuMed CVS</title>
    <sect1>
      <title>Developer CVS Access via SSH (Version 1, RSA)</title>
      <para>Only project developers can access the CVS tree via this method. SSH1 must be installed on your client machine. If you have SSH version two, add
	<screen>Host subversions.gnu.org
Protocol 1</screen>
      </para>
      <para>In my case, I simply re-installed ssh, and made sure both Protcol 1 and 2 were allowed and then put in <screen>Protocol 1,2</screen> in my <emphasis>~/.ssh/config</emphasis> file.
      </para>

      <para>Getting a ssh1 key is quite simple. You may either use an already existing ssh1-key (e.g. the one you already use to encrypt/sign your mail) or create a new one. </para>

      <sect2>
      	<title> Use an existing ssh1-key </title>
      	<para>
      	Copy the contents of the public part of the key (usually the file ~/.ssh/identity.pub to the ssh-key text field at Savannah (see below).
      	Add the line <screen>export CVS_RSH=ssh</screen> to your .profile.
      	</para>
      </sect2>
      <sect2>
      	<title> Create a new ssh1-key (using OpenSSH) </title>
      	<procedure>
	    <step>
	    	<para>
      	    	<screen> ssh-keygen [-i ~/.ssh/key_file_name] -t rsa1  </screen>
      	    	key_file_name is the name of the key you want to create. If you want to create your primary key (the key you want to use for mail etc.) you can drop the part in brackets. In this case you will find the key file in ~/.ssh/identity.pub.
      	    	</para>
	    </step>
	    <step>
      	    	<para>
      	    	Then copy and paste the contents of the public part of the key (the file ~/.ssh/key_file_name.pub to the ssh-key text field at Savannah (see below). Be sure not to copy line breaks.
		</para>
	    </step>
	    <step>
      	    	<para>
      	    	If you created a your primary key,add the line <screen>export CVS_RSH=ssh</screen> to your .profile.
      	    	</para>
		<para>
		If you created a new key particularly for the cvs, enter the following lines
		<screen> echo "#! /bin/sh\nssh -i ~/.ssh/key_file_name $@" > ~/bin/ssh_cvs
chmod +x ~/bin/ssh_cvs
    	    	</screen>
    	    	Add the line <screen>export CVS_RSH=ssh_cvs</screen> to your .profile.		
    	    	</para>
	    </step>
	</procedure>
	</sect2>
	<sect2>
	    <title> Uploading your SSH1-Key </title>
	    <para> Copy and paste the public part of the ssh1-key to savannah.gnu.org using https://savannah.gnu.org/account/editsshkeys.php.
	    </para>
	</sect2>
    </sect1>
    <sect1>
      <title>Basic commands</title>
      <para>Again just making it clear</para>
      <para>To Checkout CVS as a developer, you will type:</para>
      <screen>cvs -z3 -d<emphasis>dude</emphasis>@subversions.gnu.org:/cvsroot/gnumed/ co gnumed</screen>

      <para>To update your tree, you will type:
      <screen>cvs -z3 -ddude@subversions.gnu.org:/cvsroot/gnumed/ update -d [-P] gnumed
      </screen>
      You might want to use the -P option, which removes empty directories from your copy of the CVS.	
      </para>
      <para>To commit your changes, type:</para>
      <screen>cvs -z3 -ddude@subversions.gnu.org:/cvsroot/gnumed/ commit gnumed</screen>
      <para>Remember that you will be asked for your passphrase. This is different from your password to savannah.gnu.org</para>
    </sect1>
  </chapter>

  <chapter>
    <title>Coding Guidelines</title>
    <sect1>
      <title>strings and translation</title>
      <para>hardcoded error strings meant for developers / debugging are in English.All other strings MUST be translateable, that is called as a gettext 
function. To achieve this, you do the following:
      </para>
      <para>If your modules can be called as a standalone script you
should add this to your main part:
	<screen>
if name == '__main__':
	import gettext
	_ = gettext.gettext()
    # ... now on to other stuff
	</screen>
If your module is invoked from within the GNUmed framework the
translation function _() is automatically defined for you.
      </para>
      <para>
Now, whenever you use a string, do it like
	<screen>
print _("this will be automatically translated")
instead of
 print "this can't be translated and should thus not be written this way"
	</screen>
      </para>
    </sect1>

    <sect1>
      <title>Database Guidelines</title>
      <para>When doing database work, NEVER rely on a table being present in the "default" database. Lookup the appropriate service 
(as listed in http://gnumed.net/whitepapers/serviceslist.html) and use it 
accordingly - for example ALL person and address related details are 
available via the service "personalia" now.</para>
      <para>
Whether "personalia" is actually implemented in "default" or on some other 
server in a completely different database should not matter to client 
programmers. Just request the right service from the database broker 
object, and that's it - should work.</para>
      <para>
In order to make this testable, you must set up your configuration tables 
in the default database accordingly
(database name in "db", service in "distributed_db", reference to db and 
distributed_db in "config" attributes "db" and "ddb")
      </para>
    </sect1>

    <sect1>
      <title>Widgets</title>
      <para>When trying to map database results to widgets, remember that not all 
widgets can use the same functions (like SetValue()) under all 
circumstances to set their properties. Notable examples for exceptions are 
"choice boxes" and "combo boxes". It might be preferrable to have a 
function SetData(), UpdateData(), ClearData() for each dialog instead - 
far more control over what is actually happening to the widgets, though 
unfortunately a little bit more typing.</para>

    </sect1>

    <sect1>
      <title>Comments. Documenting Code</title>
      <sect2>
	<title>Module documention</title>
      	    <para>Always insert some lines of description of the module, containing at least the author and one line of short explanation. Remember that a lot of people might have to read and understand your code. Document as much as possible. Add example code how to use the module where possible and necessary. 
Please insert the following template at the beginning of the file:</para>
    	    	<screen>
#############################################################################
# ModuleName - one line explanation             
# verbose documentation, example code
# @author: author name                                                       
# @copyright: author                                                            
# @license: GPL (details at http://www.gnu.org)                                 
# @dependencies: any libs / program versions the module might depend on       
# @change log:                                                                  
#       date initials of the author changes made                
#                                                                               
# @TODO:        
#############################################################################
    	</screen>
      </sect2>

      <sect2>
	<title>Docstring documention</title>
      <para>try to always insert at least one line of docstring 
unless the function is no more than a couple of lines long and perfectly 
self-explanatory</para>
      </sect2>

      <sect2>
	<title>COMMENTS</title>
	<para>mark places that need fixing with a comment like this:
	  <screen>
# FIXME: a comment on what should be fixed how
... your code ...</screen>
	</para>
      </sect2>
    </sect1>

    <sect1>
      <title>CVS Guidelines</title>
      <para>Always test before you check in (yes, I have been guilty of not
  heeding my own advice, sorry)</para>
    </sect1>

    <sect1>
      <title>DEBUGGING/LOGGING</title>
      <para>Place markers before/after logging statements
  that can be commented out once things work like this:
	<screen>
#&lt;DEBUG&gt;
gmLog.Log(gmLog.lData, "this is a completely useless and wasteful, excessive log message")
#&lt;/DEBUG&gt;</screen>
    </chapter>

    <chapter>
    	<title> Modules </title>
<sect1><title>python-common</title>
<sect2><title>gmCLI.py</title><screen>

GNUmed command line options handling.

All command line argument handling should go through this module.

Theory of operation:
Upon startup the command line is parsed for any option
arguments. Those are assumed to start with at least one "-".
Any arguments not starting with a "-" are considered
non-option arguments. Option arguments are then stored in
the module level global dictionary _cli_args{}.

Your module should import gmCLI and query for existence of
one-letter arguments like this:

if gmGLI.has_arg("-v"):
	do_something_verbosely()
else:
	be_rather_quiet()

If you want to access the value for a long option you should
first check for it's existence and then access the value:

if gmCLI.has_arg("--foo"):
	print gmCLI.arg["--foo"]
else:
	print "no argument --foo specified"

Remember that even though a long argument exists it may not
have a value, e.g. the value might amount to an empty string.

Limitations:
1) Aggregated short arguments are not supported, eg you CANNOT say
    my-script -fo
   instead of
    my-script -f -o
   In fact, "-fo" will be truncated to "-f"
2) Values on short arguments are not supported. Use long
   style arguments for that, e.g.:
    my-script --foo=bar

</screen></sect2>
<sect2><title>gmCachedAddress.py</title><screen>

 gmCachedAddress - data broker for a person's address
 @TODO: Almost everything

 class AddressCache(gmDBCache.DBcache)
 class CachedAddress(gmDBCache.CachedDBObject)
	def get(self, id=None, by_reference=0, refresh_only=0):
	def create_address_link( self, addressMap, db):
	def update_address_link(self, addressMap, db):
	def dictresult(self, id=None):
</screen></sect2>
<sect2><title>gmConf.py</title><screen>
Configuration model
This duplicates some of Karsten's work, but a configuration tool is required
that talks to the remote database

def GetAllConfigs ():
def SetConfig (key, value):
# HACK FOR NOW
config = {'main.use_notebook':1, 'main.shadow':1, 'main.shadow.colour':(131, 129, 131), 'main.shadow.width':10}

</screen></sect2>
<sect2><title>gmConf.py</title>
<screen>
# gmCachedDBObject : abstraction and performance improvement for simple
#                     database query result objects
#
#
# CachedDBObject is a base class which should not
# be used directly.
# In order to derive a functional class from CachedDBObject, do as follows:
#
# class Derived(CachedDBObject):
#
#       #first, create the "shared buffer" variable
#	dbcache = DBcache()
#       #this static variable MUST have the name "dbcache"
#       #it must create an instance of DBcache or a subclass thereof
#
#       #then, create the appropriate constructor
#	def __init__(...)
#		#now create a reference to the static variable
#		self.cache = Derived.dbcache
#		#and pass it to the constructor
#		cachedDBObject.__init__( cache=self.cache...)
#               #__init__ MUST call the base class constructor
#
# When creating more than one instance from "Derived",
# the callback system should be used to ensure that any
# instance using the shared buffer gets notified of buffer changes:
#
# myInstance = Derived(...)
# myInstance.notify_me('identifier of myInstance', callback_function)
#
# where 'identifier of myInstance' is an arbitrary string and
# 'callback function' is a function of the prototype:
#
# function('identifier of callback triggering class', 'id')
#
# where 'id' typically would be the foreign key causing the
# current data set in the buffer
#

class DBcache:
	"prototype for a database object cache 'static' (singleton) information"

class CachedDBObject

	def reset(self)
		"force a re-query of buffer on next data access attempt"

	def setQueryStr(self, querystr)

	def getQueryStr(self)

	def setId(self, id, lazy=0)

	def getId(self)
		"get the ID of the current object"

	def get(self, id=None, by_reference=0, refresh_only=0):
		returns the buffer. If id is not None and not in cache,
		the backend will be queried.
		If by_reference is not zero, a copy of the buffer instead 
		of a reference to it will be returned.
		When using multiple threads to access the data,
		always use copies of the buffer!

	def notify_me(self, who, callback=None):
    		Register function 'callback' for caller 'who'

		If callback is None, the callback for caller 'who'
		will be removed (if exists)
		'callback' is a function that accepts two parameters:
		The first parameter is the identity of the registered
		caller ('who'), the second parameter is the buffer id.
		'callback' must not return anything

	def queue_notification(self, queue=1):
		simple helper mechanism to ensure only the most recent thread
		updates widgets on data change
		
	def notify(self):
		forces execution of all registered callback functions
		This function will be called whenever the buffer changes
		
	def attributes(self):
		returns row attributes ('field names')

	def pprint(self):
		"format buffer content in printable form"

	def dictresult(self):

</screen>
</sect2>
<sect2><title>gmDispatcher.py</title><screen>

     Provides global signal dispatching services.

class DispatcherError(exceptions.Exception)

class _Any:
     def connect(receiver, signal=Any, sender=Any, weak=1)
	Connect receiver to sender for signal

	If sender is Any, receiver will receive signal from any sender.
	If signal is Any, receiver will receive any signal from sender.
	If sender is None, receiver will receive signal from anonymous.
	If signal is Any and sender is None, receiver will receive any 
	    signal from anonymous.
	If signal is Any and sender is Any, receiver will receive any 
	    signal from any sender.
	If weak is true, weak references will be used.

     def disconnect(receiver, signal=Any, sender=Any, weak=1)
	Disconnect receiver from sender for signal.

	Disconnecting is not required. The use of disconnect is the same as for
	connect, only in reverse. Think of it as undoing a previous connection.

     def disconnect(receiver, signal=Any, sender=Any, weak=1)
	Disconnect receiver from sender for signal.

	Disconnecting is not required. The use of disconnect is the same as for
	connect, only in reverse. Think of it as undoing a previous connection.

     def send(signal, sender=None, **kwds)
	Send signal from sender to all connected receivers.

	Return a list of tuple pairs [(receiver, response), ... ].
	If sender is None, signal is sent anonymously.

     def _call(receiver, **kwds)
	Call receiver with only arguments it can accept.

     def safeRef(object)
	Return a *safe* weak reference to a callable object.

class BoundMethodWeakref

    def __init__(self, boundMethod):
        Return a weak-reference-like instance for a bound method.

    def __repr__(self)
        Return the closest representation.

    def __call__(self)
        Return a strong reference to the bound method.

    def _removeReceiver(receiver)
    	Remove receiver from connections.

    def _cleanupConnections(senderkey, signal)
        Delete any empty signals for senderkey. Delete senderkey if empty.

    def _removeSender(senderkey)
    	Remove senderkey from connections.

</screen></sect2>
<sect2><title>gmExceptions.py</title><screen>
class ConnectionError(Exception)
	#raised whenever the database backend connection fails

class ConfigError(Exception)
	#raised whenever a configuration error occurs

class NoGuiError(Exception):
	#raised whenever the database backend connection fails

class PureVirtualFunction(Exception):
	#raised whenever the database

</screen></sect2>
<sect2><title>gmGuiBroker.py</title><screen>
GNUMed GUI element brokerage

This module provides wrappers for the equivalent of global
variables needed for a gnumed GUI client interface

class GuiBroker:
	Wrapper for global objects needed by GNUMmed GUI clients

	#This class wraps all global gui objects (variables)for a gnumed
	#application. The static (at application level)dictionary
	#__objects can be accessed through the method addobject
	#and getobject.
	#So, if you need to access the main window frame, you would
	#query an instance of GuiBroker for it.

	def addobject(self, widget, key=None):
		Add an object to the gnumed gui object dictionary"

		An object can be anything (class, variable, widget)
		The "key" is a key expression (number, text) that
		allows you to retrieve the object.
		Convention for keys is the widget or variable name
		as a text string
		If key is not passed as parameter, a unique serial
		number is allocated as key and returned

	def getobject(self, key):
		allows to retrieve a gnumed gui element; see addobject()
		regarding the key parameter

	def keylist(self):
		returns a list of all keys; see documentation for the
		dictionary data type

	def valuelist(self):
		returns a list of all values; see documentation for the
		dictionary data type

	def itemlist(self):
		returns a list of all key:value pairs;
		see documentation for the dictionary data type

	def __getitem__(self, key):
		Allows retrieving the value via value = instance[key]

	def __setitem__(self, key, object):
		Allows access in the style of instance[key]=value

</screen></sect2>
<sect2><title>gmI18N.py</title><screen>
GNUmed client internationalization/localization.

All i18n/l10n issues should be handled through this modules.

Theory of operation:

By importing this module a textdomain providing translations is
automatically installed. The translating method gettext.gettext()
is installed into the global (!) namespace as _(). Your own modules thus
need not do _anything_ (not even import gmI18N) to have _() available
to them for translating strings. You need to make sure, however, that
gmI18N is imported in your main module before any of the modules using
it. In order to resolve circular references involving modules that
absolutely _have_ to be imported before this module you can explicitely
import gmI18N into them at the very beginning.

The text domain (i.e. the name of the message catalog file) is derived
from the name of the main executing script unless explicitely given on
the command line like this:
 --text-domain=&lt your text domain &gt

This module searches for message catalog files in 3 main locations:
 - in standard POSIX places (/usr/share/locale/ ...)
 - below $GNUMED_DIR/locale/
 - below (one level above binary directory)/locale/

For DOS/Windows I don't know of standard places so only the last
option will work unless you have CygWin installed. I don't know a
thing about classic Mac behaviour. New Mac's are POSIX, of course.

The language you want to see is derived from the following locale
related environment variables (in this order):
 - LANGUAGE
 - LC_ALL
 - LC_MESSAGES
 - LANG

</screen></sect2>
<sect2><title>gmLog.py</title><screen>

GNUMed client log handling.

All error logging, user notification and otherwise unhandled 
exception handling should go through classes or functions of 
this module

Theory of operation:

A logger object is a unifying wrapper for an arbitrary number
of log targets. A log target may be a file, syslog, the console,
or an email address, or, in fact, any object derived from the
class cLogTarget. Log targets will only log messages with at least
their own message priority level (log level). Each log target
may have it's own log level.

There's also a dummy log target that just drops messages to the floor.

By importing gmLog into your code you'll immediately have
access to a default logger: gmDefLog. Initially, the logger has
a log file as it's default target. The name of the file is
automatically derived from the name of the main application.
The log file will be found in one of the following standard
locations:

1) given on the command line as "--log-file=&lt log file &gt"
2) ~/.&lt base_name &gt/&lt base_name &gt .log
3) /var/log/&lt base_name &gt/&lt base_name &gt .log
4) /var/log/&lt base_name &gt .log
5) /dir/of/binary/&lt base_name &gt .log	- mainly for DOS/Windows

where &lt base_name &gt is derived from the name
of the main application.

By importing gmLog and logging to the default log your modules
never need to worry about the real message destination or whether
at any given time there's a valid logger available. Your MAIN
module simply adds real log targets to the default logger and
all other modules will merrily and automagically start logging
there.

You can of course instantiate any number of additional loggers
that log to different targets alltogether if you want to keep
some messages separate from others.

Usage:
1.) if desired create an instance of cLogger
2.) create appropriate log targets and add them to the default logger or your 
    own (from step 1)
3.) call the cLogger.LogXXX() functions

# log levels:
# lPanic - try to log this before we die
# lErr   - some error occured, may be recoverable
# lWarn  - something should be done about this though it's not fatal
# lInfo  - user info like program flow
# lData  - raw data processed by program

# injudicious use of lData may lead to copious amounts of log output
# and has inherent security risks (may dump raw data including passwords,
# sensitive records, etc)


class cLogger:
	def __init__(self, aTarget=None):
		Open an instance of cLogger and initialize a target.
		in case there's no target given open a dummy target

	def close(self):
		Close this logger and cleanly shutdown any open targets.

	def AddTarget (self, aTarget):
		Add another log target.

		- targets must be objects derived from cLogTarget
		- ignores identical targets
		- the number of concurrent targets is potentially unlimited

	def RemoveTarget (self, anID):
		Remove a log target by it's ID.
		- clients have to track target ID's themselves if they want to
		  remove targets

	def Log(self, aLogLevel, aMsg, aRawnessFlag = lUncooked):
		Log a message.

		- for a list of log levels see top of file
		- messages above the currently active level of logging/verbosity
		  are dropped silently
		- if Rawness == lCooked non-printables < 32 (space) will be mapped to
		  their name in ASCII
		- FIXME: this should be a Unicode mapping

	def LogDelimiter (self):
		Write a horizontal delimiter to the log target.

	def LogException(self, aMsg, exception, fatal=1):
		Log an exception.
		'exception' is a tuple as returned by sys.exc_info()

	def SetAllLogLevels (self, aLogLevel = None):
		Set a certain log level on all targets.

private classes / methods:
class cLogTarget:
	Base class for actual log target implementations.
	- derive your targets from this class
	- offers lots of generic functionality

	def __init__(self, aLogLevel = lErr)
	def close(self)
	def getID (self)
	def SetLogLevel(self, aLogLevel)
	def writeMsg (self, aLogLevel, aMsg)
	def hasLogged (self)
	def writeDelimiter (self)
	def flush (self)

</screen></sect2>
<sect2><title>gmLoginInfo.py</title><screen>
# gmLoginInfo - a class to encapsulate Postgres login information

class LoginInfo:
	"a class to encapsulate Postgres login information"

	def __init__(self, user, passwd, host='localhost', port=5432, database='gnumed', options='', tty='', profile='default'):

	def SetInfo(self, user, passwd, host='localhost', port=5432, dbname='gnumed', opt='', tty='', profile='default'):

	def GetInfo(self):

	def GetInfoStr(self):
	    # doesn't hand out passwords 

	def GetPGDB_DSN(self):
    	    return dsn in colon delimited form as one string and host
	    
	def GetDBAPI_DSN(self):
    	    return dsn in colon delimited form as one string
	  
    	def SetUser(self, user):
	def GetUser(self):
	def SetPassword(self, passwd):
	def SetPassword(self, passwd):
	def GetPasswordHash(self):
	def SetDatabase(self, dbname):
	def GetDatabase(self):
	def SetHost(self, host):
	def SetHost(self, host):
	def SetPort(self, port):
	def GetPort(self):
	def SetOptions(self, opt):
	def GetOptions(self):
	def SetTTY(self, tty):
	def GetTTY(self):
	def GetTTY(self):
	def GetTTY(self):

	def Clear(self):
		"clears all connection information regarding user, password etc."

</screen></sect2>
<sect2><title>gmPG.py</title><screen>
# gmConnectionPool - Broker for Postgres distributed backend connections

as of 09.08.2002 tries to handle psycopg (Zope), PyPGSql and pgdb

class ConnectionPool:
	"maintains a static dictionary of available database connections

	def __init__(self, login=None):
		parameter login is of type gmLoginInfo.LoginInfo

	def GetConnection(self, service):
		"if a distributed service exists, return it - otherwise return the default server"

	def ReleaseConnection(self, service):
		"decrease reference counter of active connection"

	def GetAvailableServices(self):
		list all distributed services available on this system
		(according to configuration database)

	def Connected(self):

	def LogError(self, msg):
		"This function must be overridden by GUI applications"

#---------------------------------------------------
# database helper functions
#---------------------------------------------------
def cursorIndex(cursor):
	returns a dictionary of row atribute names and their row indices

def descriptionIndex(cursordescription):
	returns a dictionary of row atribute names and their row indices

def dictResult(cursor, fetched=None):
	"returns the all rows fetchable by the cursor as dictionary (attribute:value)"

def fieldNames(cursor):
	"returns the attribute names of the fetched rows in natural sequence as a list"
	
def listDatabases(service='default'):
	"list all accessible databases on the database backend of the specified service"

def listUserTables(service='default'):
	"list the tables except all system tables of the specified service"

def listSystemTables(service='default'):
	"list the system tables of the specified service"

def listSystemTables(service='default'):
	"list the system tables of the specified service"

def quickROQuery(query, service='default'):
	a quick read-only query that fetches all possible results at once
	returns the tuple containing the fetched rows and the cursor 'description' object

def getBackendName():

def prompted_input(prompt, default=None):

def inputTMLoginParams():
	text mode input request of database login parameters

def inputWXLoginParams():
	GUI (wx) mode input request of database login parameters.
	Returns gmLoginInfo.LoginInfo object

def inputLoginParams():
	"input request for database backend login parameters. Try GUI dialog if available"

</screen></sect2>
<sect2><title>gmPlugin.py</title><screen>

# gmPlugin - base classes for GNUMed's plugin architecture
class gmPlugin:
	base class for all gnumed plugins

	def provides ():
		Returns a list of services that the plugin provides

	def requires ():
		Requires a list of services that must be registered
		before this plugin is registered. The configuration
		tool must check these and make sure the load order
		satisfies the plugins' requirements

	def description ():
		Returns a brief description of the plugin.

	def name (self):

	def register(self):

	def unregister(self):

class wxBasePlugin (gmPlugin):
	
	
	base class for all plugins providing wxPython widgets.
	Plugins must have a class descending of this class in their file, which MUST HAVE THE SAME NAME AS THE FILE.
	The file must be in a directory which is loaded by LoadPluginSet (gui/ for the moment, others may be added for different plugin types)

	# NOTE: I anticipate that all plugins will in fact be derived
	# from this class. Without the brokers a plugin is useless (IH)

	def __init__(self, guibroker=None, callbackbroker=None, dbbroker=None, params=None):

	def GetIcon (self):
		Return icon representing page on the toolbar.
		This is the default behaviour. GetIconData should return
		pickled, compressed and escaped string with the icon data.

		If you want to change the behaviour (because you want to load
		plugin icons from overseas via a satellite link or something
		you need to override this function in your plugin (class).

		Using this standard code also allows us to only import cPickle
		and zlib here and not in each and every plugin module which
		should speed up plugin load time :-)

		# FIXME: load from config which plugin we want
		# which_icon is a cookie stored on the backend by a config manager,
		# it tells the plugin which icon to return data for,

	def GetIconData(self, anIconID = None):
		# FIXME: in overriding methods need to be very careful about the
		# type of the icon ID since if we read it back from the database we
		# may not know what type it was

	def GetWidget (self, parent):
		Return the widget to display

	def MenuInfo (self):
		Return tuple of (menuname, menuitem).
		menuname can be "tools", "view", "help", "file"

	def Raise (self):
		Raises this plugin to the top level if not visible.

	def Shown (self):
		Called whenever this module is shown onscreen.

class wxNotebookPlugin (wxBasePlugin):
	
	Base plugin for plugins which provide a 'big page'
	Either whole screen, or notebook if it exists
		
	def register (self):
		Register ourselves with the main notebook widget.

	def unregister (self):
		Remove ourselves.

	def Raise (self):
	def OnMenu (self, event):
	def GetNotebookNumber (self):
	def DoToolbar (self, tb, widget):
		
		sets up the toolbar for this widget.
		tb is the toolbar
		widget is the widget returned by GetWidget () for connecting events


class wxPatientPlugin (wxBasePlugin):
	
	A 'small page', sits inside the patient view, with the side visible

	def register (self)
	def OnTool (self, event):
	def Raise (self):
	def unregister (self):


def LoadPlugin (aPackage, plugin_name, guibroker = None, dbbroker = None):
	Loads a plugin from a package directory.

	- "set" specifies the subdirectory in which to find the plugin
	- this knows nothing of databases, all it does is load a named plugin

	There will be a general 'gui' directory for large GUI
	components: prescritions, etc., then several others for more
	specific types: export/import filters, crypto algorithms
	guibroker, dbbroker are broker objects provided
	defaults are the default set of plugins to be loaded

	FIXME: we should inform the user about failing plugins

def GetAllPlugins (set):
	
	Searches the directory for all plugins

def UnloadPlugin (set, name):
	
	Unloads the named plugin

</screen></sect2>
<sect2><title>gmdbf.py</title><screen>

This is a module for reading dbf files.

It has been modified thanks to suggestions and patches from Jeff Bauer
and Kevin Dahlhausen. Unfortunately I lost patches which fix
endianness problems, which were sent to me by someone, so that will
have to wait. I do not use this module much these days, but since it
seems to be in use "out there" I thought I would finally make an
update available. This version should be more portable. Also, rather
than printing an error message an exception is now raised when the dbf
file appears to be corrupt.

Usage: the following

import dbf
db = dbf.dbf('mydata.dbf')

creates a dbf object db associated with an existing dbf file
'mydata.dbf'.  The dbf file is opened by the constructor. If the file
is not there IOError is raised. If the file appears not to be a dbf
format file, TypeError is raised.

If you prefer to create a dbf object, but open the actual file later,
you can use the following:

import dbf
db = dbf.dbf('mydata.dbf', openit=0)

and then you can call

db.open()

to actually open the file. Note that the constructor, if called this
way, does not verify that the file is there, so the IOError exception
is raised by the call to open.

Once the dbf object is created and opened (implicitly or not), the
following are available:

-- db.fields  : returns a a list of tuples describing the fields
-- db.nrecs   : returns the number of records
-- db[n]      : returns a tuple containing record number n (0 <= n < nrecs)
-- db.status(): prints some essential data about the dbf file

So to list the first two fields of mydata.dbf, assuming they are string
fields, one might write:

import dbf
from string import strip
db=dbf.dbf('mydata.dbf')
for k in db:
    print "%s, %s" % (strip(k[1]), strip(k[2]))


Good luck!

class dbf:
	def __init__(self, fname, openit=1):
	def open(self):
	def _get(self, recno):
	def __getitem__(self, recno):
	def dictresult(self, recno):
	def status(self):
	def close(self):


</screen>
</sect2>
</sect1>
<sect1><title>wxpython</title>
<sect2><title>gnumed.py</title><screen>
main wrapper setting up global brokers, logging, command line argument handling, i18n, etc.
GNUmed
======
This is the launcher for the main GNUmed GUI client. It is
intended to be used as a standalone program.

Command line arguments:

--quiet
 Be extra quiet and show only _real_ errors in the log.
--debug
 Be extra verbose and report nearly everything that's going
 on. Useful for, well, debugging :-)
--talkback
 Run the client and upon exiting run a talkback client where
 you can enter a comment and send the log off to the bug hunters.
 Very useful when used in conjunction with --debug.
--text-domain=<&lt a_text_domain &gt
 Set this to change the name of the language file to be loaded.
 Note, this does not change the directory the file is searched in,
 only the name of the file where messages are loaded from. The
 standard textdomain is, of course, "gnumed.mo".
--log-file=&lt a_log_file> &gt
 Use this to change the name of the log file.
 See gmLog.py to find out where the standard log file would
 end up.
--help, -h, or -?
 Well, show this help.


def get_base_dir():
	Retrieve the global base directory.

	   The most preferable approach would be to just let
	   the user specify the name of a config file on the
	   command line but for that we'd have to load some
	   non-standard modules already unless we want to
	   duplicate the entire config file infrastructure
	   right here.

	   1) regardless of OS if the environment variable GNUMED_DIR
		  is set this directory will be tried as a base dir
		  - this will allow people to start GNUmed from any dir
		    they want on any OS they happen to run
		  - the variable name has been chosen to be descriptive
		    but still not waste too many resources
	   2) assume /usr/share/gnumed/ as base dir
		  - this will work on POSIX systems and may work on
		    Cygwin systems
		  - this is the no-brainer for stock UN*X
	   3) finally try one level below path to binary
	      - last resort for lesser systems
		  - this is the no-brainer for DOS/Windows
		  - it also allows running from a local CVS copy


further action:
- import gmLog, gmCLI
- import gmI18N, gmGuiBroker, gmGuiMain
- import gmTalkback if necessary

jump to gmGuiMain.main()

</screen></sect2>
<sect2><title>gmGuiMain.py</title><screen>

GNUMed GUI client
The application framework and main window of the
all signing all dancing GNUMed reference client.

from wxPython.wx import *
from wxPython.html import *

import gmLogFrame, gmGuiBroker, gmPG, gmSQLSimpleSearch, gmSelectPerson, gmConf, gmLog, gmPlugin
import images
import images_gnuMedGP_Toolbar                 #bitmaps for use on the toolbar
import images_gnuMedGP_TabbedLists             #bitmaps for tabs on notebook
import gmGuiElement_HeadingCaptionPanel        #panel class to display top headings
import gmGuiElement_DividerCaptionPanel        #panel class to display sub-headings or divider headings 
import gmGuiElement_AlertCaptionPanel          #panel to hold flashing alert messages
import gmGP_PatientPicture                     #panel to display patients picture 
import gmGP_Toolbar                            #panel with two toolbars on top of the screen

from gmI18N import gmTimeformat

class MainFrame(wxFrame):
	GNUmed client's main windows frame
	This is where it all happens. Avoid popping up any other windows.
	Most user interaction should happen to and from widgets within this frame

	def __init__(self, parent, id, title, size=wxPyDefaultSize):
		You'll have to browse the source to understand what the constructor does

		# initialize the gui broker
		# allow access to a safe exit function for all modules in case of "emergencies"
		# setup status bar
		# allow all modules to access our status bar
    	    	
		# connect to backend

    	    	# get current user and display it

    	    	# setup platform dependent data
		# create menus
		# setup accelerators
		# register events

		# create the  the main sizer to contain all the others on the form
		# create a top vertical box sizer for the main window
	
		# create a horizontal sizer which will contain all windows at the top of the
		# screen (ie menu's and picture panel - which are on sub sizers)
		# add a wxPanel to this sizer which sits on the left and occupies 90% of width
		# followed by panel for the patients picture which occupies 10%. Add labels for
		# demo patients

		# setup the "top row", where all important patient data is always on display
		# set up the main notebook (gmNotebook)
		# relate plugins to the notebook (via gmPlugin.GetAllPlugins ('gui'))
		# position the Window on the desktop and show it


	def SetupPlatformDependent(self):
		#do the platform dependent stuff

	def OnNotebook (self, event):
		Called when notebook changes

	def RegisterEvents(self):
		#register events we want to react to

	def OnAbout(self, event):
		" A simple 'about' dialog box"

	def SetupAccelerators(self):
	def SetupStatusBar(self):
		#add time and date display to the right corner of the status bar
		#update every second

	def Notify(self):
		Displays date and local time in the second slot of the status bar"

	def CreateMenu(self):
		Create the main menu entries. Individual entries are
		farmed out to the modules

	def Lock(self):
		Lock GNUmed client against unauthorized access"

	def Unlock(self):
		Unlock the main notebook widgets
		As long as we are not logged into the database backend,
		all pages but the 'login' page of the main notebook widget
		are locked; i.e. not accessible by the user

		#unlock notebook pages
		# go straight to patient selection

	def OnFileExit(self, event):

	def CleanExit(self):
		This function should ALWAYS be called when this
		program is to be terminated.
		ANY code that should be executed before a regular shutdown
		should go in here
    
    	def OnClose(self,event):

	def OnIdle(self, event):
		Here we can process any background tasks

	def OnIconize(self, event):

	def OnMaximize(self, event):

	def OnPageChanged(self, event):

class gmApp(wxApp):
	def OnInit(self):
		# do platform dependent stuff
		# create a static GUI element dictionary;
    	    	# show the login window
		# create the MainFrame		

def main():
	GNUmed client written in Python
	to run this application simply call main() or run the module as "main"
	#create an instance of our GNUmed main application
	#and enter the main event loop

gnumed.py calls gmGuiMain.main() 
gmGuiMain.main() creates gmApp
gmApp creates MainFrame
MainFrame sets up the toolbar, top row, Menus (items will be added by the plugins)
main sizers and loads all plugins in directory wxpython/gui

gmApp enters wx event loop, waiting for some action


</screen></sect2>
<sect2><title>gmAppoint.py</title><screen>
# gmAppoint - A simple interface to the appointments book.
#             INCOMPLETE, do not link in to rest of app.

</screen></sect2>
<sect2><title>gmCryptoWidget.py</title><screen>

This module implements a ""crypto"" aware text widget

This text widget allows arbitrary text to be entered via keyboard,
cut'n paste via clipboard, or text files via drag'n drop
Right clicking pops up a menu that allows to encrypt or decrypt
the selected text segment.

class gmTextctrlFileDropTarget(wxFileDropTarget):
     a generic text control widget that accepts dropped files 

    def __init__(self, textwindow):
    def OnDropFiles(self, x, y, filenames):
        inserts the dropped file(s) content(s) at the cursor position

class gmCryptoText(wxTextCtrl):
    A special text widget that supports cryptography

    A right mouse click pops up a manu that allows to encrypt
    or decrypt selected text segments.
    You can drag and drop any number of text files into the text
    widget, and that text will be inserted at the current cursor
    position

    def __init__(self, parent, id, size=wxPyDefaultSize, style=wxTE_MULTILINE|wxTE_RICH, defaulttext=None):

    def OnRightClick(self, event):
        A right mouse click triggers a popup menu for cryptographic
	functionality"

    def OnContextMenu(self, event):

    def OnEncrypt(self, event):
        triggered by popup contect menu event

    def OnDecrypt(self, event):
    def OnSetPassphrase(self, event):
    def OnRightDown(self, event):
        dummy function; if this event was not intercepted, GTK would
        clear the text selection the very moment the mouse button is clicked

    def AskForPassphrase(self):
        asks for a pass phrase and returns it

    def Encrypt(self, cleartext, key):
        override this function for your own crypto funcs

    def Decrypt(self, ciphertext, key, identtag):
        override this function for your own crypto funcs

    def StripIdentTag(self, text):
        Remove the 'ident tag' from text and return both tag and test
    def GetIdentTag(self):
        This is a 'virtual' function which should be overridden to provide your own meaningful tag

    def SetFuzzyMargin(self, margin):
        The fuzzy margin is the number of characters on each side of the text selection
        the decryption algorithm will search for correct delimiters. It should be at least as long as
        the IdentTag is plus an extra 3 characters to allow for the crypto tag

    def FuzzyScanSelection(self, frompos, topos, margin):

</screen></sect2>
<sect2><title>gmEditArea.py</title><screen>
The classes in this file are not used until now. 

class  EditAreaTextBox(wxTextCtrl):
#text control class to be later replaced by the gmPhraseWheel
	def __init__ (self, parent, id, wxDefaultPostion, wxDefaultSize):

class EditAreaPromptLabel(wxStaticText):
#Class which shows a blue bold label left justified
	def __init__(self, parent, id, prompt, aColor = richards_blue):

class EditAreaPrompts(wxPanel):
#create the editorprompts class which expects a dictionary of labels passed to it
#with prompts relevent to the editing area.
	def __init__(self,parent,id,prompt_array):

class EditTextBoxes(wxPanel):
#Class central to gnumed data input
#allows data entry of multiple different types.e.g scripts,
#referrals, measurements, recalls etc
#section = calling section eg allergies, script

have a look at the source code if you want to know what it is doing.

</screen></sect2>
<sect2><title>gmGuiElement_AlertCaptionPanel.py</title><screen>
base classes for captioned alert divider on left hand side of
notebook page "patient"
</screen></sect2>
<sect2><title>gmGuiElement_DividerCaptionPanel.py</title><screen>
base classes for captioned dividers on left hand side of
notebook page "patient"
</screen></sect2>
<sect2><title>gmGuiElement_HeadingCaptionPanel.py</title><screen>
base classes for captioned heading divider on left hand side of
notebook page "patient"

gmGuiMain.py
- inits wxPython GUI framework

</screen></sect2>
<sect2><title>gmLogFrame.py</title><screen>
not used anymore, really

</screen></sect2>
<sect2><title>gmLoginDialog.py</title><screen>
encapsulates the first dialog, the login window.
should be del()ed after use, actually

</screen></sect2>
<sect2><title>gmLogin.py</title><screen>
- encapsulates the login information as a python object

</screen></sect2>
<sect2><title>gmMDWImporter.py</title><screen>
- not related to framework
- implements data import from on commercial australian medical
  software

</screen></sect2>
<sect2><title>gmShadow.py</title><screen>
- encapsulates custom widget shadow object to be used on all
  Richard-Terry-Style widgets (possibly more)

</screen></sect2>
<sect2><title>gmTalkback.py</title><screen>
- encapsulates talkback app

</screen></sect2>
<sect2><title>gmUserAdmin.py</title><screen>
- unrelated to framework as of now
</screen>
</sect2>
</sect1>

<sect1><title>wxpython/gui - "whole page" plugin widgets regarding the notebook</title>
<para>TODO</para>
</sect1>
<sect1><title>wxpython/gui-de - same as ../gui for Germany (AMIS-browser should life here)</title>
<para>TODO</para>
</sect1>

<sect1><title>wxpython/patient - "patient page" plugin widgets</title>
<para>TODO</para>
</sect1>
	
</chapter>


    <chapter>
    	<title> Design </title>
	<sect1>
	    <title>GNUMed Database Architecture</title>
    	    <sect2>	
    	    	<title>Client-Server architecture with optional middleware layers</title>
    	    	<para>
    	    	GNUMed is designed as a <emphasis>client-server</emphasis> architecture with <emphasis>optional middleware</emphasis> components.
		The database backend is provided by PostgreSQL, a largely SQL-92 compliant  object-relational
		database server. PostgreSQL is free software, obtainable at http://www.postgresql.org. 
		It is portable, running on virtually all Posix compatible systems including Gnu/Linux, 
		BSD Unix, Solaris, Mac OS/X. Although we do not recommend it, it can be run on Microsoft
		Windows NT, 2000 and XP.
    	    	</para> 
    	    </sect2>
            <sect2>
	    	<title>Distribution of database services</title>
    	    	<para>
    	    	GNUMed allows distributions of database services. Closely related information like a person's
		name and address are regarded as a "service", which may or may not be hosted on the same physical 
		server as other services. Developers have to refer to the list of services when designing database 
		queries. A <emphasis>central pivot database</emphasis> provides information about the nature and whereabouts of 
		distributed services. On the client side, distribution is made transparent to the developer
		and end user through a <emphasis>"database service broker"</emphasis> object which not only hides information about
		service distribution, but can also be used for load balancing , reusable connections and database
		replication in future versions. 
    	    	</para>
	    </sect2>
    	    <sect2>
	    	<title>Normalization of data</title>
    	    	<para>
    	    	Tables are <emphasis>normalized</emphasis> to the  3rd normal form as long as this does not deteriorate query performance
		too much. In order to simplify client software development, a <emphasis>pseudo-denormalization</emphasis> is achieved through
		updateable views. Foreign key constraints ensure <emphasis>referential integrity</emphasis> of highly normalized data.
		Reference counter tables keep track of <emphasis>cross-database relational integrity</emphasis>, as PostgreSQL does not allow
		(yet) cross-database constraints and queries.
		</para>
    	    </sect2>
    	    <sect2>
	    	<title>Audit trailing</title>
    	    	<para>
    	    	<emphasis>Trigger functions</emphasis> ensure business logic and <emphasis>audit trailing</emphasis> . Deleting and updating of data is caught by
		triggers, and copies of the originals are kept in audit trail tables at all times. Database programmers
		need not to worry about this, as all audit trail related triggers and tables are generated automatically.
		In order to achieve this, we do use postgres specific extensions such as table inheritance and built-in 
		procedural languages such as pgsql, pgtcl and pgpython. Thus, gnumed can not be
    	    	easily ported to a different database backend.
    	    	</para>
    	    </sect2>
    	    <sect2>
	    	<title>Access control</title>
    	    	<para>
    	    	The PostgreSQL server supports <emphasis>secure authentication protocols</emphasis> such as Kerberos as well as <emphasis>secure
		communication protocols</emphasis> between client and server(s) such as SSL. In addition, data of more strictly
		confidential data wil be stored encrypted with arbitrary algorithms; although the cryptographic process
		is performed on the client side, this is supported by the GNUMed server through a sophisticated key management.
		A user hierarchy can be implemented, and access to tables and procedures can be regulated through this hierarchy
		on the server side.
    	    	</para>
	    </sect2>	
    	    <sect2>
	    <title>Multigenerational concurrency control and backups</title>
    	    <para>
    	    PostgreSQL uses a multigenerational concurrency control system. This not only avoids most locking situations,
	    but also allows <emphasis>life "snapshot" backups</emphasis> of the complete database system while the system is running even under
	    full load.
	    </para>
	    </sect2>
    	</sect1>


	<sect1>
	    <title>List of distributed database services</title>
    	    <sect2>
	    <title>Configuration - the service administering all other services</title>
	    <para></para>
	    </sect2>	

    	    <sect2>
    	    	<title>Person related services</title> 

    	    	<informaltable frame=all>
    	    	    <tgroup cols=2>
    	    	    <colspec colwidth="1*">
    	    	    <colspec colwidth="5*">
    	    	    <tbody>
    	    	    	<row><entry>Service name:</entry><entry>Personalia</entry></row>
    	    	    	<row><entry>Provides:</entry>
    	    	    	    <entry><itemizedlist mark=opencircle>
    	    	    	    	<listitem><para>
    	    	                    All information directly related to a person's identity, biological and social relationships
                    	    	    excluding confidential data (like credit card information) 
				</para></listitem>
				<listitem><para>
    				    All geographical information, including  
				</para></listitem>
				<listitem><para>
                		    Personal communication related information (phone numbers, fax, email, web sites, pagers) 
				</para>
				</listitem>
				</itemizedlist></entry></row>
    	    	    	<row><entry>Access level:</entry><entry>all staff</entry></row>
    	    	    </tbody>
    	    	    </tgroup>
		    <tgroup cols=3>
			<colspec colwidth="1*">
			<colspec colwidth="1*">
			<colspec colwidth="3*">
			<tbody>
			    <row><entry>Related Scripts:</entry><entry>gnumed.sql</entry>
			    <entry> priming of database (creation of procedural languages, basic access
                                    permissions, audit trail priming)
			    </entry></row>
			    <row><entry></entry><entry>gmgis.sql</entry><entry>
                            	    geographic information in the widest sense; streets, cities, states, nations,
                            	    postcodes ...
			    </entry></row>
			    <row><entry></entry><entry>gmidentity.sql</entry><entry>
                            	    a person's identity, names, relationships, and a many-to-many pivot table
                            	    linking identities to addresses
			    </entry></row>
			    <row><entry></entry><entry>gmcommunication.sql</entry><entry>
                            	    phone & fax numbers, email addresses, web sites, pagers, etc. and a
                            	    many-to-many pivot table linking identities to communication URLs
			    </entry></row>
			</tbody>
		    </tgroup>
    	    	</informaltable>

	    </sect2>	

    	    <sect2>
        	<title>Medical history related services</title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    past medical  history / diagnoses 
		    </para></listitem>
		    <listitem><para>
		    active medical problems
		    </para></listitem>
		    <listitem><para>
		    progress reports
		    </para></listitem>
		    <listitem><para>
		    social history 
		    </para></listitem>
		    <listitem><para>
		    family history 
		    </para></listitem>
		    <listitem><para>
		    substance abuse history 
		    </para></listitem>
		    <listitem><para>
		    allergies 
		    </para></listitem>
		    <listitem><para>
		    vaccinations
		    </para></listitem>
		    <listitem><para>
		    past medication & current prescriptions
		    </para></listitem>
		</orderedlist>
	    </sect2>	

    	    <sect2>
    	        <title>External results </title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    pathology results 
		    </para></listitem>
		    <listitem><para>
		    imaging results
		    </para></listitem>
		</orderedlist>
	    </sect2>	

    	    <sect2>
    	        <title>Correspondence </title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    sent documents (referrals, certificates) 
		    </para></listitem>
		    <listitem><para>
		    received documents (discharge summaries, specialist reports)
		    </para></listitem>
		</orderedlist>
	    </sect2>	

    	    <sect2>
    	        <title>Pharmaceutical reference </title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    drug listing: generic and brand names 
		    </para></listitem>
		    <listitem><para>
		    drug properties 
		    </para></listitem>
		    <listitem><para>
		    consumer product information  
		    </para></listitem>
		    <listitem><para>
		    interactions
		    </para></listitem>
		</orderedlist>
	    </sect2>	
    	    
	    <sect2>
    	    	<title>General medical reference </title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    coding (i.e. LOINC, ICD-10)
		    </para></listitem>
		</orderedlist>
	    </sect2>	

    	    <sect2>
    	    	<title>Decision support database </title>
    	    	<para></para>
	    </sect2>	
    	    
	    <sect2>
    	        <title>Large binary objects (BLOBS)</title>
    	    	<para></para>
	    </sect2>	
    	    
	    <sect2>
    	        <title>Accounting related services</title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    billing 
		    </para></listitem>
		    <listitem><para>
		    tax related information 
		    </para></listitem>
		    <listitem><para>
		    stock tracking
		    </para></listitem>
		    <listitem><para>
		    ordering supplies
		    </para></listitem>
		</orderedlist>
	    </sect2>	
    	    <sect2>
    	       <title>Office related services</title>
		<orderedlist numeration="arabic">
		    <listitem><para>
		    waiting room 
		    </para></listitem>
		    <listitem><para>
		    appointments 
		    </para></listitem>
		    <listitem><para>
		    recalls 
		    </para></listitem>
		</orderedlist>
    	    </sect2>
    	</sect1>	
	
	<sect1>
	<title>FAQ</title>
    	<para>
> I would be interested in hearing about the database design 
> history and the purpose of the distributed database architecture
> that you have implemented, (smart, but possibly a little 
> over-kill I would have thought at first glance).
    	    </para>
	    <para>
	    Horst Herb:The main reason why we had to split the monolithic backend up:
- some countries provide centralized demographic information. It would 
be inefficient and unreliable to try to copy such a centrally well 
maintained demographic database. We should rather allow to tap into it 
via distributed services.
- some countries provide centralized pharmaceutical information
- some countries provide centralized immunisation databases
- some conutries centralize certain pathology results
etc.

Sometimes, this happens on a smaller scale like within a hospital where 
hey already have successfully implemented some of these services, they 
are running smoothly, and they find no reason to pull it apart again. 
GNUMed will shine in such an environment because it will be far easier 
to integrate into such existing solutions than other software.

Thus we try to find out which "services" are relatively independent from 
  others, and isolate them into particular "virtual" databases. That 
way, it will be magnitudes easier to write simple wrappers for external 
sources and use them.

The main obstacle is tha Postgres in itself does not support 
cross-database queries, and we have to take care of referential 
integrity between external sources ourselves.

Note: we should put in a description on how this is achieved now
(client side) vs. how we would want this (either built into postgres
or via a dedicated demon on the backend with listen/notify)
	    </para>
	    
	    <para>
	    Karsten Hilbert: 
There isn't really much choice: Doing everything in one
monolithic database isn't quite flexible enough (distributed
practices with a WAN link, remote clinical repository but
local drug information data store). The difference between
hardcoding 2 or 3 database and doing it the Right Way as we
are trying to do now isn't very much of a difference. So there
aren't really many steps inbetween "monolithic" and
"distributed according to some configuration". Yes, it's a bit
more complex but to the client side it shouldn't be any more
complex than:

dbbrooker.GetConnection('personalia')
dbbrooker.GetConnection('BLOBS')

If we then properly encapsulate accesses into objects we don't
experience too much pain in using the distributed version.

It does get a bit more involved with keeping strict
referential integrity across databases but Horst can explain
the issues better than me.
    	    </para>
	    
	</sect1>

	<sect1>
	    <title>GUI design</title>
	    <para>TODO</para>
	</sect1>

</book>
