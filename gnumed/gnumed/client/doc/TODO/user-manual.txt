# $Source: /home/ncq/Projekte/cvs2git/vcs-mirror/gnumed/gnumed/client/doc/TODO/Attic/user-manual.txt,v $
# $Revision: 1.19 $
---------------------------------------------------
Rules:
------
- add material for the User Manual in this text file if you
  don't want to edit the sgml code yourself
- leave behind an email address
- delete things if you incorporated them into the manual
- please date it.
Thanks
---------------------------------------------------
Karsten.Hilbert@gmx.net Mon 06 Jan 2003 09:24:15 CET

The plugin configuration is now implemented as follows:

IMHO this is GnuMed configuration information. Actually it
should live in an Administrators Guide as discussed recently
on the list but for now we can share admin and user staff
in the User Manual since we don't have much user level
information yet...

Upon startup GnuMed tries to read a list of which plugins to
load. It looks in several places:

1) in the database (the config tables in gmconfiguration.sql
   need to be imported)
   a) as the current user on the current machine
   b) as the current user on the "default" machine
   c) as the "default" user on the current machine
   d) as the "default" user on the "default" machine
2) in the file plugins.conf in the corresponding plugin
   directory (note that the format changed - this is now
   expected to be a standard gmCfg config file, group is
   "plugins", the list option "load order")
3) direct scan of the plugin directory

If any of the stages one b-d finds corresponding data that
configuration is saved specific to the current user/machine.

If stage two finds a plugins.conf file it assumes that the
admin has set up a default for all users of this machine and
thus writes that configuration into the database specific to
the current user/machine.

Stage three will always load all available plugins. It will
therefore write that configuration into the database specific
to the machine but not specific to a user (eg. to the default
user).

Subsequent loading will thus find the configuration at earlier
stages. Thusly the client should be autoconfiguring to a
certain degree.

I have not yet connected to the backend explicit add/drop of
plugins via Ian's new popup menu. This will come next.
---------------------------------------------------
Karsten.Hilbert@gmx.net    Mit 08 Jan 2003 12:06:34 CET

pyPgSQL v2.3 is needed for db config string list support.

Note: 2.3beta does NOT work !
---------------------------------------------------
Karsten.Hilbert@gmx.net		Son 12 Jan 2003 20:25:27 CET

GnuMed database user structure

PostgreSQL does not support read-write versus read-only connections.
To protect us from unwanted writes we emulate this separation by
setting up two accounts per user. The normal account name "user" is
used for read-only connections. This is ensured by only granting
SELECT rights to those accounts. The read-write account name is
formed by prepending a "_" to the normal account such that "user"
has a companian account named "_user". Those accounts are granted
appropriate INSERT, DELETE and UPDATE rights in the database.

As it is very tedious to grant rights to each and every single
account the concept of user groups is used. A group "group" is
actually granted SELECT rights only, while "_group" receives
INSERT, UPDATE, and DELETE rights on database objects. Users
are simply added to those groups, name "user" to group "group" and
"_user" to group "_group" thereby acquiring the respective database
rights.

Default groups that always exist in a properly configured GnuMed
database are:

gm-doctors			_gm-doctors
gm-staff_medical	_gm-staff_medical
gm-staff_office		_gm-staff_office
gm-trainees_medical
gm-trainees_office
gm-public

Notice how there are no write rights for trainees and the public.

gmPG will return read-only connections by default. If a read-write
connection is requested  by means of setting read_only = 0 a new
connection to the service is instantiated for the user "_CURRENT_USER".
Read-only connections are cached and shared, read-write ones are not.
-------------------------------------------------------
Karsten.Hilbert@gmx.net    Mon 27 Jan 2003 03:08:59 CET

Replace 2.5 with the following:

2.5. Configuring PostgreSQL for GnuMed

This section applies distribution/OS independent.

GnuMed database 101
-------------------
GnuMed does not simply store all of it's data in a monolithic database.
It rather uses the concept of a service. A service is a set of tables
relating to a semantically reasonably distinct part of the data. It's
probably easiest to understand via the example of the "blobs" service.
This service stores medical documents relating to patients. These can
be scans of referral letters or discharge summaries, paper-based lab
results or incoming faxes. Any aggregate of diverse medical data on a
patient that's not easily split up and stored.

Other services include "default" (the core database tables that tell
your client software which service is to be found where), "personalia"
(holding all the patient demographics), and various clinical services
for drug data, clinical history, etc. The authoritative list of services
is found in server/sql/gmconfiguration.sql. Any service living in the
same database as the "default" service does not need to be mapped
explicitely (but it can). If there's no mapping it is assumed that
a service lives in the "default" service's database.

Services can coexist in one and the same database on a single server
or be spread out across several databases or even servers both on-site
and off-site. However, non-monolithic services have not been tested
well yet and will require the non-standard dblink PostgreSQL extension
(found in contrib/ in the PostgreSQL source tree). Until further notice
it is recommended to stick to non-distribution of services via
monolithic databases except for services that don't require
cross-database referential integrity links such as a drug database
for informational purposes. What has been tested successfully, however,
is access to GnuMed databases over WAN links, including via internet
from arbitrary locations.

Database setup
--------------
The theory roughly goes like this:

- create databases
- import all the necessary tables for the services you
  want to support
- import any necessary translation files for the languages
  you wish to support
- grant appropriate access rights
- set up service-to-database/server mappings

All of this is handled automatically by the script bootstrap-gm_db_system.py
living in server/utils/. This script does not yet set up mappings of
services to their databases/servers (although in theory it can install
services on remote servers already). As this is not yet fully supported by
GnuMed anyways (due to dblink being non-standard) one should stick
to a monolithic service layout. Several sample config files for
bootstrapping are supplied in server/utils/. They can be used by calling
the script like this:
 bootstrap-gm_db_system.py --conf-file=<a config file>
To set up a straightforward monolithic system on the local machine use
the config file localhost-monolithic.conf.sample.

Make sure to remove test accounts and to set up your own config file
if you want to go life.

If you want to tweak things by hand read the config files and the source
of the bootstrapping scripts. All the config file parameters are documented
in bootstrap-gm_db_system.conf.sample
----------------------------------------------------------
