$Source: /home/ncq/Projekte/cvs2git/vcs-mirror/gnumed/gnumed/client/doc/TODO/developer-guide.txt,v $
$Revision: 1.21 $
--------------------------------------------------------------
Rules:
------
- add material for the Developer's Guide here if you don't want
  to put it into the sgml code yourself
- leave behind an email address
- Please date it. Thanks
- delete things if you incorporated them into the guide
--------------------------------------------------------------
Mon 05 Mai 2003 14:52:08 CEST   Karsten.Hilbert@gmx.net

The GnuMed EMR
==============

Required reading
----------------
Weed: the problem-oriented medical record (SOAP, POMR)
 use Google

Slee: loss-free entity coding in medicine
 http://www.tringa.com/index.php?submit=HCCC

Dutch model: Episodes of Care
 http://www.phcsg.org.uk/conferences/cambridge1998/westerhof.htm

-------------------------
Structural considerations
-------------------------
Health Issue
------------
A Health Issue is a longer ranging medical condition associated with
a patient. There may be several episodes related with one health
issue and there must be at least one. At times a health issue will
first be appreciated by considering underlying similarities between
several medically related episodes. A health issue may have a finite
duration if the underlying medical condition is eventually fully
resolved. It may also span the entire life of the patient such as
in chronic or genetic ailments. Start and end are not directly
recorded but must be derived from the start of the earliest and
the end of the most recent associated episode.

Clinical Episode
----------------
A Clinical Episode denotes a period of time during which the patient
was under care for one particular Health Issue (medical condition).
Several episodes (eg. progression, bouts, etc.) may be associated
with a particular health issue. There can be several encounters per
episode, there must be at least one. The start and end of an episode
isn't directly recorded but rather one can deduce that data from the
associated clinical items of which there will usually be several
(but at least one). Often, several providers will contribute to an
episode of care (via several encounters and items). One would think
that episodes can be deduced from clusters of closely related dates
of clinical encounters. While this is true it cannot be used reliably
in a programmatic way.

Clinical Encounter
------------------
A one-off contact between patient and health care system (or on behalf
of the patient) is called a "Clinical Encounter". An encounter is often
restricted to a given date but may span midnight and will thus refer to
two dates. The date itself is not directly stored in the encounter
table clin_encounter but must be determined from the commit timestamps
of the clinical items belonging to it. The encounter table records the
location, provider and subject of care as well as the type of encounter.
It really is more of an administrative than a purely clinical concept.
Note that it also does not fit hospital stays particularly well where
it is harder to define clean boundaries between encounters. One
encounter will often relate to more than one episode/health issue.

Clinical Item
-------------
In GnuMed a medically meaningful piece of information is called "Clinical
Item". Such items are typically elements of the SOAP structure such as a
diagnosis, a history item, an assessment, a plan, etc. Several tables,
both specific and generic store such items. They all inherit from the
table clin_root_item which records the Clinical Encounter and Clinical
Episode this item belongs to. Virtue of inheriting from clin_root_item all
Clinical Item tables also have a generic "narrative" field for comments
and clinical narrative.

Partial Contact
---------------
This concept of the Dutch Episode Model is not directly
represented in the GnuMed clinical table structure. It is
easily derived from the existing data by aggregating all
Clinical Items that belong to the same Clinical Encounter
and the same Clinical Episode.

-----------------------------
Implementation considerations
-----------------------------
Clinical narrative
------------------
Due to the fact that clinical items are stored in several different
specific and non-specific tables it is difficult to do a full-text
search across the medical record of a patient. For this reason all
clinical narrative is aggregated in the clin_root_item table. All
tables providing clinical narrative are supposed to inherit from
this table. If more than one field for free text is needed in a
table links to entries in clin_note must be used additionally
to the inherited clin_root_item.narrative field.

The view v_patient_items provides an aggregation of clinical
items per patient. From this one can derive the item ID and source
table of individual items. It also provides the full text of the
clinical narrative for all tables that inherit from clinical item.
Only very few clinically relevant narrative strings are not stored
in such tables, namely comments on clin_episode, clin_encounter
and clin_health_issue rows.

View v_patient_episodes
-----------------------
This view links episodes to patients.

View v_i18n_patient_encounters
------------------------------
This view links encounters to patients and provides a translated
encounter type (if a translation is available).

Predefined data
---------------
Wherever fixed strings are predefined for certain fields (such
as descriptions of encounter types or history item types) provisions
for translation of those strings via gmI18N.sql must be made. An
ID range for user-supplied additional strings must be defined. The
default language is English, other languages are handled via
translations. In appropriate cases views may facilitate easier
access to translated strings. Names of such views are to be
prepended by "v_i18n_".

Clinical items
--------------
All tables holding clinical items must inherit from clin_root_item.

=========================================
medically:

health issue

-> several episodes
   -> several encounters
      -> several partial contacts
         -> several items
--------------------------------------------------------------
Don 22 Mai 2003 15:30:47 CEST   Karsten.Hilbert@gmx.net

GnuMed table auditing
=====================

From a medico-legal point of view it is important to track who
changed what data when. GnuMed uses database level facilities
to achieve that goal. Advantages are that SQL query parsing is
left to the database engine, that the backend provides uniform
auditing across any variety of client, and that data is moved
locally which provides for reasonable speeds. Drawbacks are
that audit trail data cannot be transferred remotely right away
particularly conveniently and that this scheme is not foolproof
against manipulation.

INSERT
------
On INSERT the committer and the current timestamp is added to
the table data. Row versioning is initialized to 0. No data
is transferred to the corresponding audit trail table.

UPDATE/DELETE
-------------
On any of those two operations the original row version, data,
committer, timestamp and table OID are logged in the audit trail
table. The current timestamp, committer and action (DELETE or
UPDATE) are added. For updates, the row version in the original
table is incremented and the timestamp and committer are
updated to the current values.

SELECT
------
Currently SELECTs are not logged. While some legislation may
require this it does not make sense technically, will slow down
the database considerably and is better left to middleware
or frontend. The main argument against SELECT logging at the
database level is that the intended purpose of it would be to
enable later investigation of unauthorized disclosure. However,
a logged SELECT in no way proves any disclosure to any specific
target. A missing SELECT does not contribute any useful evidence
against disclosure either. Unauthorized disclosure is largely
a social-control/policy issue. There's no such thing as
"unauthorized access". If access occurred it was authorized
(barring any software bugs). Such security breaches must be
prevented by other means.

How to add an audit trail to a table
------------------------------------
Any table that is supposed to be audited must inherit
from the audit marker table "audit_mark". In order for
auditing to actually work a corresponding audit trail
table must be created. Audit trail tables customarily
start with the prefix "log_" and must inherit from
the audit trail root table "audit_trail". Those
parameters are, of course, configurable. The audit
trail tables need not contain all the columns in the
audited table but they may not contain any additional
columns except for those inherited from the audit trail
root table.

During bootstrapping all marked tables that have a
corresponding audit trail table are prepared for
auditing. The necessary functions and triggers are
automatically generated and inserted into the database.
If you know of a dependable way of generating audit
trail tables from audited tables please contact the
author. Until then, audit trail tables must be pre-
defined just as the original tables but without any
constraints except for "not null" where appropriate.
There are some examples in server/sql/gmclinical.sql.

Please read the source in
server/bootstrap/gmAuditSchemaGenerator.py and
server/bootstrap/boostrap*.py to learn how to manually
create audit trails.

Audit trail handling
--------------------
Over time the audit trail tables may grow quite large.
They may be dumped and cleaned out regularly. The
dump file should be notarized digitally and backed up.
Preferably an unsigned online copy of the audit trail
tables should be moved to another server. It is useful
to have the complete revision history online for
reference but this is not speed-critical.
--------------------------------------------------------------
Sam 14 Jun 2003 13:29:04 CEST    karsten.hilbert@gmx.net

addition to CVS guidelines:

set the execute bit on those files only that are actually
supposed to get executed directly
--------------------------------------------------------------
Sam 05 Jul 2003 16:50:49 CEST  Karsten.Hilbert@gmx.net

Section "Logging in" (2.2.4.1) in the Dev Guide:

Move to User Manual
---------------------------------------------------
